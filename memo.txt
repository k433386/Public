.map(_.toInt) //与えられた関数を配列のすべての要素に対して呼び出す　+　toInt

.take(n) //最初のn個の要素からなるリストを求める
.drop(n) //最初のn個の要素を除いたリストを求める

.combinations(n) //n個選択する組み合わせを生成する
.permutations //順列の組み合わせを生成する

.max
.min
.product

.update
.updated

.sorted //配列を昇順で並び替える
.sortBy(_.X) //指定した要素で配列を並び替える

.filter(x => X) //指定した要素で新しい配列を取得

.distinct //重複を除いた新リストを取得

.indexOf() //インデックスを取得

.mkString() //配列を文字列として結合

.count(x => X) //条件を満たす要素を数える

.groupBy(x => (i, j)) //要素でグループ化

for (X <- Array) // 配列の要素を直接取り出す
for ((name, amount) <- result) //複数を同時に取ることもある (タプル)

Array.ofDim[]() //N次元配列の定義
Array.fill()() //初期値埋め
Array.fill(N)(Array.empty[Int]) //配列を空の配列で満たす
X.flatMap(_.toList) //配列の要素を一行にまとめる

var X : Array[] = Array.empty //空の配列の定義
var X : Map[] = Map.empty //空のマップの定義
Map = Map - key //キーと要素の消去

toUpper
toLower //char
toUpperCase
toLowerCase //string

.isDigit //数値であることを判定する

String.format("%10s", x).replace(" ", "0") //文字のゼロ桁埋め

string " "
char ' '

scala.collection.immutable.Queue[Int]()
import scala.collection.mutable.Queue
queue.dequeue()
queue.enqueue()

val X: List[(Int, Int)] = (0 until H).foldLeft(List.empty[(Int, Int)]){
    (acc, i) => (0 until W).foldLeft(acc){
        (innerAcc, j) => if (Y) {(i, j) :: innerAcc} else {innerAcc}
    }
} 

.foreach(println) //全要素プリント

.trim() //入力の前後の空白をトリミングする

---注意---
classの継承用に空のメソッドを作ること
割り算はDoubleでキャストしておいたほうが吉
Int/Longを疑うこと
mapの要素はArrayにしないほうが吉
sortByを多用するよりもsortWithを関数化するほうが安定するかも
returnを明示したほうが安定するかも

foldLeftの使い方を確認すること
式が値を持つせいで関数内の順番がシビアかも
空白をトリミングしておくと吉